<script src="https://unpkg.com/jquery"></script>
<script src="https://unpkg.com/xstream/dist/xstream.js"></script>
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<script>
  var FCIL = /** @class */ (function () {
    function FCIL(out, op) {
        this.out = out;
        this.op = op;
    }
    FCIL.prototype._n = function (t) {
        this.out._n(t);
    };
    FCIL.prototype._e = function (err) {
        this.out._e(err);
    };
    FCIL.prototype._c = function () {
        this.op.less();
    };
    return FCIL;
}());
var FlattenConcOperator = /** @class */ (function () {
    function FlattenConcOperator(ins) {
        this.ins = ins;
        this.type = 'flattenConcurrently';
        this.active = 1; // number of outers and inners that have not yet ended
        this.out = null;
    }
    FlattenConcOperator.prototype._start = function (out) {
        this.out = out;
        this.ins._add(this);
    };
    FlattenConcOperator.prototype._stop = function () {
        this.ins._remove(this);
        this.active = 1;
        this.out = null;
    };
    FlattenConcOperator.prototype.less = function () {
        if (--this.active === 0) {
            var u = this.out;
            if (!u)
                return;
            u._c();
        }
    };
    FlattenConcOperator.prototype._n = function (s) {
        var u = this.out;
        if (!u)
            return;
        this.active++;
        s._add(new FCIL(u, this));
    };
    FlattenConcOperator.prototype._e = function (err) {
        var u = this.out;
        if (!u)
            return;
        u._e(err);
    };
    FlattenConcOperator.prototype._c = function () {
        this.less();
    };
    return FlattenConcOperator;
}());
/**
 * Flattens a "stream of streams", handling multiple concurrent nested streams
 * simultaneously.
 *
 * If the input stream is a stream that emits streams, then this operator will
 * return an output stream which is a flat stream: emits regular events. The
 * flattening happens concurrently. It works like this: when the input stream
 * emits a nested stream, *flattenConcurrently* will start imitating that
 * nested one. When the next nested stream is emitted on the input stream,
 * *flattenConcurrently* will also imitate that new one, but will continue to
 * imitate the previous nested streams as well.
 *
 * Marble diagram:
 *
 * ```text
 * --+--------+---------------
 *   \        \
 *    \       ----1----2---3--
 *    --a--b----c----d--------
 *     flattenConcurrently
 * -----a--b----c-1--d-2---3--
 * ```
 *
 * @return {Stream}
 */
function flattenConcurrently(ins) {
    return new xstream.Stream(new FlattenConcOperator(ins));
}
</script>
<script src="../dist/vue-xs.js"></script>

<p>Type to search Wikipedia</p>

<div id="el">
  <button v-on:click="destroy">destroy</button>
  <input v-model="search">
  <div v-if="results">
    <h1>{{ results.term }}</h1>
    <ul v-if="results.matches.length">
      <li v-for="match in results.matches">
        <a :href="match.url">{{ match.title }}</a>
        <p>{{ match.description }}</p>
      </li>
    </ul>
    <p v-else>
      No matches found.
    </p>
  </div>
</div>

<script>
function fetchTerm (term) {
  return xstream.Stream.fromPromise($.ajax({
    url: 'http://en.wikipedia.org/w/api.php',
    dataType: 'jsonp',
    data: {
      action: 'opensearch',
      format: 'json',
      search: term
    }
  }).promise())
}

function formatResult (res) {
  return {
    term: res[0],
    matches: res[1].map((title, i) => ({
      title: title,
      description: res[2][i],
      url: res[3][i]
    }))
  }
}

var vm = new Vue({
  el: '#el',
  data: {
    search: ''
  },
  methods: {
    destroy() {
      this.$destroy()
    }
  },
  subscriptions () {
    return {
      // this is the example in RxJS's readme.
      results: this.$watchAsStream('search')
        .map(val => val.newValue)
        .filter(text => text.length > 2)
        .map(fetchTerm)
        .compose(flattenConcurrently)
        .map(formatResult)
    }
  }
})</script>
